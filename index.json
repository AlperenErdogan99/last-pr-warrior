[{"categories":null,"content":"In this article, I will try to explain in an instructive way how I control the SHT21 sensor in the project I have realized. Then I will finish my article with a sample temperature measurement code. I performed this check with the Nucleo-f303re development board I have. The SHT21 sensor is designed to measure temperature and humidity. It has two modes, Hold Master and No Hold Master, for measuring. I will use it in Hold Master mode. It uses the I2C communication protocol for data exchange. For more detailed information, you can review the manufacturer’s source that I will add below. https://www.farnell.com/datasheets/1780639.pdf First of all, I examine how I should use pins. Pin Out After these examinations, I examine the command table and image below to learn how to measure using the I2C communication protocol. Cmd Table Send Cmd Let’s examine in detail how to read and write operations with the specified commands. Read Write Information To summarize the above review, we have two addresses to choose from according to our writing and reading situations. With these addresses, I will easily measure temperature and humidity by using the commands in the “Command Table” according to our needs. Let’s examine the sample project I created using STM32CubeIde. I used the HAL library while creating this project. Ide Config After making the I2C Configuration above, let’s create our code. #define START_TEMP_HM 0xE3 /*!\u003cstart hold master temperature measurement */ #define WRITE_ADDRESS 0X80 /*!\u003cwrite address for command */ void sht21_start_T_HM(void) { uint8_t data[] = { START_TEMP_HM }; HAL_I2C_Master_Transmit(\u0026hi2c1, (uint8_t) WRITE_ADDRESS, data, 1, HAL_MAX_DELAY); HAL_Delay(200); } typedef struct { uint8_t T_DATA[2] ; /*!\u003craw humidity sensor data */ uint16_t Temperature_Value[2] ; uint16_t Temperature ; /*!\u003cprocessed temperature sensor data */ char data_T[20]; /*!\u003cfinal temperature for LCD and WIZNET */ double son_sicaklik ; /*!\u003cfinal temperature */ }SHT21_Handle_t; void sht21_read_T_HM(SHT21_Handle_t *sht21_1) { uint8_t data[1]; data[1] = READ_ADDRESS; HAL_I2C_Master_Transmit(\u0026hi2c1, (uint8_t) WRITE_ADDRESS, (uint8_t*) data, 1,1000); HAL_I2C_Master_Receive(\u0026hi2c1, (uint8_t) READ_ADDRESS, sht21_1-\u003eT_DATA, 2,1000); HAL_Delay(200); sht21_1-\u003eTemperature_Value[0] = sht21_1-\u003eT_DATA[0]; //MSB sht21_1-\u003eTemperature_Value[0] = sht21_1-\u003eTemperature_Value[0] \u003c\u003c 8; sht21_1-\u003eTemperature_Value[1] = sht21_1-\u003eT_DATA[1]; //LSB sht21_1-\u003eTemperature_Value[1] = sht21_1-\u003eTemperature_Value[1] \u0026 ((uint16_t) LSB_CONFIG); sht21_1-\u003eTemperature = sht21_1-\u003eTemperature_Value[0]| sht21_1-\u003eTemperature_Value[1]; } By examining and revising these functions, you can use the sensor as you wish. I hope it was useful. Waiting for your feedback, good work. ","date":"2022-09-20","objectID":"/how-to-use-sht21-with-stm32/:0:0","tags":null,"title":"How to Use Sht21 With Stm32","uri":"/how-to-use-sht21-with-stm32/"},{"categories":null,"content":"In this article, I will explain how to use wiznet5500 with Stm32. What is Wiznet module? WIZnet (Wizard of Internet) is a unique Hardwired Internet Connectivity Solution Provider. WIZnet provides IOcP and HW TCP/IP chips, best fitted for low-end Non-OS devices connecting to the Ethernet for the internet of things. WIZnet’s core technology is “Hardwired TCP/IP“. Let’s list the reasons why it is useful. Supporting SPI. Providing a Useful API to its users. (Socket API) Availability of an up-to-date forum page and providing fast support through this page. The documents published for users are detailed and understandable. You can access Wiznet documentation from this link: http://wizwiki.net/wiki/doku.php?id=products:w5500:datasheet In this article, I will run my module in tcp client mode. Let’s do this step by step. First, let’s learn how to use the pins of the module that we will use from the manufacturer’s source that I have added above. Pin Out Let’s start programming the module. First, we add the library published by the manufacturer to our project. Then we determine the IP address of our module. wizchip_init(bufSize, bufSize); wiz_NetInfo netInfo = { .mac = {0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef}, // Mac address .ip = {192, 168, 2, 192}, // IP address .sn = {255, 255, 255, 0}, // Subnet mask .gw = {192, 168, 2, 1}}; // Gateway address wizchip_setnetinfo(\u0026netInfo); wizchip_getnetinfo(\u0026netInfo); The number of sockets I can use in our module varies according to the model. There are 8 sockets in the W5500 model. We define them. bufSize[] = {2, 2, 2, 2, 2, 2, 2, 2}; We activate the SPI communication on our development board. I am implementing it via STM32CubeIde. Ide Config In order to control the manufacturer’s library with the SPI interface that I have activated, we define two functions that can read and write 1 byte, working through the SPI communication protocol, to the relevant functions in the library. void cs_sel() { HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET); //CS LOW } void cs_desel() { HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET); //CS HIGH } uint8_t spi_rb(void) { uint8_t rbuf; HAL_SPI_Receive(\u0026hspi2, \u0026rbuf, 1, 0xFFFFFFFF); return rbuf; } void spi_wb(uint8_t b) { HAL_SPI_Transmit(\u0026hspi2, \u0026b, 1, 0xFFFFFFFF); } The library we use is not only a library published for the w5500 model. Therefore, we go into our library and select the corresponding macro value. #define _WIZCHIP_ 5500 // 5100, 5200, 5300, 5500 We are setting the timeout. void timeout_config(void) { wiz_NetTimeout gWIZNETTIME = {.retry_cnt = 3, //RCR = 3 .time_100us = 2000}; //RTR = 2000 ctlnetwork(CN_SET_TIMEOUT,(void*)\u0026gWIZNETTIME); //set timeout w5500 ctlnetwork(CN_GET_TIMEOUT,(void*)\u0026gWIZNETTIME); //set timeout w5500 } We create a struct structure to control the functions we will write. typedef struct { uint8_t connect_cnt ; uint8_t socket_num ; /*!\u003ccounter for socket() */ uint8_t close_cnt ; /*!\u003ccounter for close() */ uint8_t socket_cnt ; /*!\u003ccounter for socket port */ uint16_t server_port ; /*!\u003ccounter for server port */ uint16_t socket_port ; /*!\u003ccounter for socket number */ uint8_t rbuf ; /*!\u003ccounter for connect() */ } W5500_Handle_t; We have made the necessary initial adjustments. Now we are writing a connection initiation function using the library we added from the manufacturer’s source to connect to the relevant server by running our module in client mode. In this function, we determine the port number we are interested in, the socket number and the IP address we want to connect to. void connect_server(W5500_Handle_t *w5500_ports) { w5500_ports-\u003eclose_cnt = 10 ; w5500_ports-\u003econnect_cnt = 0 ; w5500_ports-\u003eserver_port = 5656 ; w5500_ports-\u003esocket_cnt = 10 ; w5500_ports-\u003esocket_num = 0 ; w5500_ports-\u003esocket_port = 5656 ; uint8_t server_ip[4] = {192,168,1,2} ; // Server's IP Address if((w5500_ports-\u003esocket_cnt = socket(w5500_ports-\u003esocket_num,Sn_MR_TCP,w5500_ports-\u003esocket_port,SF_TCP_NODELAY))==w5500_ports-\u003esocket_num) { HAL_Delay(250); w","date":"2022-09-20","objectID":"/how-to-use-wiznet5500/:0:0","tags":null,"title":"How to use Wiznet5500 with Stm32","uri":"/how-to-use-wiznet5500/"},{"categories":null,"content":"In this article, I will give informations about the ‘How to use external flash memory with Nucleo-f303re development board’. In order to strengthen the narrative, I will proceed through the following topics. 1) What is Flash Memory? 2) What is the internal structure of Flash Memory? 3) How do you communicate with the MX25R8035F Flash Memory? 4) How to use MX25R8035F? 1) What is Flash Memory? Flash Memory is a type of memory that does not lose its information even in a power cut and can be written and erased repeatedly. It is included in the development boards as an internal peripheral. If the memory space available here is insufficient, we have to use an external memory. We can solve this requirement with flash memory units. 2) What is the internal structure of Flash Memory? The data we send is stored in block structures. There are tens of pages (depending on the amount of memory) in each block structure. Internal Structure Every data is stored in the page structures inside. To send data to page structures, that structure must be cleared beforehand. If the page we want to write data on is not cleaned, we probably cannot write the data or write it in a corrupted way. In order to avoid such problems, we must make sure that these pages are clean before storing data. There is one point I would like to mention here. Each flash memory has a certain number of write-read lifetimes. If we clean before each write, we will cut the life of the peripheral in half. This poses a serious problem. The way to be followed in this regard, if we want to send data, our priority is always empty pages. Instead of cleaning the full page and writing the data, we should use the clean area. Things to consider when choosing a Flash Memory are: Read/Write Speed Read/Write Life Communication protocol type 3) How do you communicate with the MX25R8035F Flash Memory? MX25R8035F Flash Memory uses SPI as communication protocol. Therefore, you should have a good command of SPI. I’m just going to talk about how to use the SPI protocol. While answering this question, let’s first examine the pins of the peripheral. Flash Memory PinOut We will use pins 1,2,4,5,6 and 8 from the above pins in order to communicate with SPI by running our peripheral. Pins 4 and 8 will be used for feeds. The remaining pins will be used for the SPI connection. CS# : Channel selection SO: SPI -\u003eMISO SI: SPI -\u003e MOSI SCLK: SPI -\u003eSCLK In order for our peripheral to wake up and become active, the CS# pin is pulled to a low (logic 0). To use SPI, we perform the configuration settings via STM32CubeIde as follows (You can revise the SPI speed according to the limit in the user guide): IDE Configuration The following commands written with the HAL library are used to send and read data: HAL_SPI_Transmit(\u0026hspi1, \u0026spi_tx_buf[0], 1, 500); HAL_SPI_Receive(\u0026hspi1, \u0026spi_rx_buf[0], 1, 500); 4) How to use MX25R8035F? In order to control the MX25R8035F Flash Memory external peripheral, I will use a library that I have supplied and then revised and brought into working condition, and the user guide published by the manufacturer. I will share example codes in the article. First of all, I will try to examine each of its structures piece by piece. Please find manufacturer guide !!! Let’s start by reviewing our library. First we create some struct structures and variables. As we explain the functions in the library, we will understand why we defined the variables in the structures here. # define RxBufferSize 260 typedef struct { unsigned char Status; unsigned short Sector; unsigned char Page; } ExtFlash_t; typedef struct { unsigned char WIP; //write in progress unsigned char WEL; //Write Enable Latch unsigned char BPbits; //block protect unsigned char QE; //quad enable bit unsigned char SRWD; //status register write disable bit } StatusRegister_t; typedef struct { unsigned char SOTP; unsigned char LDSO; unsigned char PSB; unsigned char ESB; unsigned char PFAIL; unsigned char EFAIL; } SecurityRegister_t; typedef s","date":"2022-09-19","objectID":"/how-to-use-external-flash-memorymx25r8035f-with-stm32/:0:0","tags":null,"title":"How to Use External Flash Memory(MX25R8035F) with Stm32","uri":"/how-to-use-external-flash-memorymx25r8035f-with-stm32/"},{"categories":null,"content":"Who Am I","date":"2022-09-19","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"I am a software engineer in Turkey and I graduated from Electronics and Communication Engineering. During my university education, I interested with Embedded System Programming, Machine Learning and Deep Learning. I started my professional life as an Embedded Software Engineer. I made progress in C++, OOP, Qml, Linux, Yocto Project and Git and contributed to the company I work for. Then I started my new job as a software engineer. Nowadays, I started working on a more complex system using the topics of my previous job. In addition, in my personal life, I work to learn about Docker, Data structures and Design Pattern. In today, I am starting to share what I’ve learned on my blog. I hope it will be useful to someone. ","date":"2022-09-19","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]